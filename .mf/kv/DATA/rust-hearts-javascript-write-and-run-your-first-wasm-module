{
  "dateWritten": "2021-12-11T09:52:46.000Z",
  "title": "Rust ❤️ JavaScript",
  "lede": "Learn how to run Rust functions from your JavaScript code using the new hotness, WASM",
  "content": "## What's Wasm?\n\nWebAssembly (WASM for short) is a \"binary instruction format\" that can run natively in your browser, making it just the fourth language to claim that title, joining HTML, CSS, and JavaScript.\n\nHowever, WASM is not something that most of us will want to write by hand; that's why it was intended as a compilation target for other programming languages. The goal is to write in your favorite compiled language and then output a `.wasm` module that can be directly executed in the browser (or Deno and Node!).\n\nThis is a pretty big deal!\n\nWebAssembly modules are often used for cross-platform mobility or to off-load intensive computations away from JavaScript to a better-suited language.\n\nLet's write and run our first WebAssembly module using Rust and [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/introduction.html).\n\n## Prerequisites\n\n1. Install Rust and Cargo\n\n   - **For macOS, Linux**\n\n     ```bash\n     curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n     ```\n\n   - **For Windows**\n\n     [rustup-init.exe](https://static.rust-lang.org/rustup/dist/i686-pc-windows-gnu/rustup-init.exe)\n\n1. Install `wasm-pack`\n\n   ```bash\n   cargo install wasm-pack\n   ```\n\n## Scaffolding a Project Using Cargo\n\nAfter ensuring you have Rust, Cargo, and `wasm-pack` installed, let's create a new Rust project with Cargo.\n\n```bash\ncargo new --lib hello-wasm\n```\n\nThis command scaffolds a new Rust library in the `hello-wasm` directory. Cargo provides us with a `src/lib.rs` file and a `Cargo.toml` (think `package.json` equivalent). `lib.rs` will contain a boilerplate Rust unit test, we can go ahead and delete everything in this file.\n\n## Using `wasm-bindgen` and `wasm-pack` to Compile Rust Functions to WASM\n\nNext, let's get our `Cargo.toml` set up.\n\n```toml\n[package]\nname = \"hello-wasm\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2\"\n```\n\nWe need to add two things here: the `[lib]` section and the `wasm-bindgen` dependency.\n\nThe `[lib].crate-type` directive helps tip off Cargo that we might be building for a WASM target and helps it pass the correct flags when we do so.\n\nYou will see where we use `wasm-bindgen` in a second, but it's a key library that enables the translation between Rust types and JavaScript types, among other things. You can read more about the specifics in [their docs](https://rustwasm.github.io/wasm-bindgen/).\n\nWith our `Cargo.toml` in order, let's open up `src/lib.rs` and write some Rust code.\n\nUsing the `wasm-bindgen` attribute, we will write an `add` function that simply returns the sum of two integers.\n\n```rust\n// lib.rs\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\nNow that our Rust code is in place, we will use `wasm-pack` to compile our Rust into consumable WASM.\n\n```bash\nwasm-pack build --target web\n```\n\nYou should see a new `pkg` directory with our `.wasm` module, a `.js` wrapper, and some other sundry files. Feel free to poke around to satisfy any curiosities.\n\nWith our built artifacts, we are ready to run WASM from the browser!\n\n## Importing and Calling WASM Functions from JavaScript\n\nIn the same `hello-wasm` directory, create a humble `index.html` and add an inline `<script type=\"module\">` in the `<head>`.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Hello Wasm!</title>\n    <script type=\"module\"></script>\n  </head>\n  <body></body>\n</html>\n```\n\nNext, we can import both the default export (I call it `init`) and our `add` function from the light JavaScript wrapper that was generated by `wasm-pack`. `wasm-pack` automatically adds a default export that is essentially glue code to load and instantiate our WASM module.\n\n**It's critical that you call this default export before using the `add` function.**\n\nThen, we can call our `add` function and log the result.\n\n> `wasm-pack` generates `.d.ts` files by default. Depending on your tooling setup, this gives you autocomplete and type checking for our WASM functions 🤯.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Hello Wasm!</title>\n    <script type=\"module\">\n      import init, { add } from './pkg/hello_wasm.js'\n\n      await init() // this loads and instantiates our WASM module\n      console.log(add(1, 2)) // this calls our compiled Rust function!\n    </script>\n  </head>\n  <body></body>\n</html>\n```\n\nNow, run `python3 -m http.server` in this directory, load up `localhost:8000`, and pop open the developer tools.\n\nIf you see `3` in the console. we have had great success!\n\n> Serving `index.html` with a relatively modern HTTP server is crucial for loading our WASM module because the `application/wasm` MIME type must be supported. Opening our page from the file system _will not work_. If you have trouble with the Python server, check [here](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server#running_a_simple_local_http_server) or use an alternative server that you are comfortable with.\n\n## What Now?\n\nWebAssembly opens up a new horizon of opportunities for web applications and you now have the super power of knowing how to use it!\n\nTo learn more about WASM, `wasm-pack`, and Rust, check out these resources:\n\n- [**Rust docs**](https://www.rust-lang.org/)\n- [**WebAssembly**](https://webassembly.org/)\n- [**`wasm-pack`**](https://rustwasm.github.io/docs/wasm-pack/)\n\nSee the final source code [here](https://github.com/austincrim/hello-wasm).\n\nIf you have any questions or issues, feel free to reach out on my [Twitter](https://twitter.com/crim_codes).\n"
}