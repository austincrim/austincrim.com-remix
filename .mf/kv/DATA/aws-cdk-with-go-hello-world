{"content":"## Background\n\nI recently started exploring the AWS CDK using Go. The Go CDK library is currently in Developer Preview, meaning the APIs are subject to change and it should not be used in production. However, it should be used to experiment and provide feedback to AWS!\\\nI wanted to spin up a simple Lambda fronted by API Gateway to create an HTTP API, a very common use case. I have pasted the full source of both the CDK and the Lambda handler below.\n```go\n    // lib/cdk.go\n    package main\n\n    import (\n    \t\"os\"\n\n    \t\"github.com/aws/aws-cdk-go/awscdk\"\n    \t\"github.com/aws/aws-cdk-go/awscdk/awsapigatewayv2\"\n    \t\"github.com/aws/aws-cdk-go/awscdk/awsapigatewayv2integrations\"\n    \t\"github.com/aws/aws-cdk-go/awscdk/awslambda\"\n    \t\"github.com/aws/constructs-go/constructs/v3\"\n    \t\"github.com/aws/jsii-runtime-go\"\n    )\n\n    type GoCdkStackProps struct {\n    \tawscdk.StackProps\n    }\n\n    func NewGoCdkStack(scope constructs.Construct, id string, props *GoCdkStackProps) awscdk.Stack {\n    \tvar sprops awscdk.StackProps\n    \tif props != nil {\n    \t\tsprops = props.StackProps\n    \t}\n    \tstack := awscdk.NewStack(scope, &id, &sprops)\n\n    \t// The code that defines your stack goes here\n\n    \tfunction := awslambda.NewFunction(stack, jsii.String(\"gofunction\"), &awslambda.FunctionProps{\n    \t\tFunctionName: jsii.String(\"hellogo\"),\n    \t\tCode:         awslambda.AssetCode_FromAsset(jsii.String(\"../handler\"), nil),\n    \t\tHandler:      jsii.String(\"handler\"),\n    \t\tRuntime:      awslambda.Runtime_GO_1_X(),\n    \t})\n\n    \tintegration := awsapigatewayv2integrations.NewLambdaProxyIntegration(&awsapigatewayv2integrations.LambdaProxyIntegrationProps{\n    \t\tHandler:              function,\n    \t\tPayloadFormatVersion: awsapigatewayv2.PayloadFormatVersion_VERSION_1_0(),\n    \t})\n\n    \tapi := awsapigatewayv2.NewHttpApi(stack, jsii.String(\"goapi\"), &awsapigatewayv2.HttpApiProps{\n    \t\tApiName: jsii.String(\"hellogoapi\"),\n    \t})\n\n    \tapi.AddRoutes(&awsapigatewayv2.AddRoutesOptions{\n    \t\tPath:        jsii.String(\"/\"),\n    \t\tIntegration: integration,\n    \t})\n\n    \treturn stack\n    }\n\n    func main() {\n    \tapp := awscdk.NewApp(nil)\n\n    \tNewGoCdkStack(app, \"GoCdkStack\", &GoCdkStackProps{\n    \t\tawscdk.StackProps{\n    \t\t\tStackName: jsii.String(\"GoCDKStack\"),\n    \t\t\tEnv:       env(),\n    \t\t},\n    \t})\n\n    \tapp.Synth(nil)\n    }\n\n    // env determines the AWS environment (account+region) in which our stack is to\n    // be deployed. For more information see: https://docs.aws.amazon.com/cdk/latest/guide/environments.html\n    func env() *awscdk.Environment {\n    \treturn &awscdk.Environment{\n    \t\tAccount: jsii.String(os.Getenv(\"CDK_DEFAULT_ACCOUNT\")),\n    \t\tRegion:  jsii.String(os.Getenv(\"CDK_DEFAULT_REGION\")),\n    \t}\n    }\n```\n```go\n    // handler/main.go\n    package main\n\n    import (\n    \t\"context\"\n    \t\"fmt\"\n\n    \t\"github.com/aws/aws-lambda-go/events\"\n    \t\"github.com/aws/aws-lambda-go/lambda\"\n    )\n\n    func HandleRequest(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\n    \tname := request.QueryStringParameters[\"name\"]\n    \tif name == \"\" {\n    \t\tname = \"Friend\"\n    \t}\n    \treturn events.APIGatewayProxyResponse{Body: fmt.Sprintf(\"Hello, %s!\", name), StatusCode: 200}, nil\n    }\n\n    func main() {\n    \tlambda.Start(HandleRequest)\n    }\n```\nAllow me to highlight a few concepts that tripped me up.\n\n### Finding the Go CDK packages\n\nSince the CDK bindings for Go are currently in developer preview, the documentation is not quite as fleshed out as the other supported languages. This made getting started a little hairy. In the end I found most of what I needed [here](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-construct-library.html), after selecting the v2 release candidate from the menu in the top right.\\\nOne major benefit of CDK 2.0 is having all the various packages under a single namespace. This makes it trivial to grab more dependencies as you go, simply changing the last node of your import statements.\n\n### jsii.String()?\n\nMost examples of Go CDK that I found on AWS' docs included calls to `jsii.String()` or similar. This call has to wrap any literal data types that you wish to pass, such as string or integer primitives. All construct options structs take pointers, even for things like strings or integers. This is because Go does not natively support optional struct fields. `jsii.String()` will automatically provide a pointer to your string literal value, this allows for a `nil` pointer to be used for optional fields that you choose not to provide.\n\n### Specifying a Lambda Handler  \n```go\nawslambda.NewFunction(stack, jsii.String(\"gofunction\"), &awslambda.FunctionProps{\n  ...\n  Handler:      jsii.String(\"handler\"),\n  ...\n})\n```\nThis option took me the longest to figure out and partially inspired me to write this post. When specifying the `Handler` option of a new Lambda function, you specify the **name of the executable file generated by `go build`**. So in my scenario, I have a folder named **handler** that contains a **main.go** file. When built, this creates a **handler** executable. This is what needs to go in the `Handler` struct field.\\\nAnother important note, when building your executable, **you have to run `GOOS=linux go build`** or the Windows equivalent. This tells the Go cli to build an executable for the Linux OS which is where your Lambda will actually run. If you don't do this, you will get a runtime error when executing your lambda.\n\nThat wraps it up for this post, let me know if you run into any other common issues I could add!\n"}